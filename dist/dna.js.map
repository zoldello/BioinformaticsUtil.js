{"version":3,"sources":["sanitizeDNAString.js","complement.js","dna.js","getCount.js","isValid.js","reverse.js","standardMessage.js"],"names":[],"mappings":"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","file":"dna.js","sourcesContent":["//import isValid from './isValid';\nimport {invalidDNAMessage } from './standardMessage';\n\n// internal use only\nexport function sanitizeDNAString(dNAString) {\n    if (false) {\n        throw new Error(invalidDNAMessage(dNAString));\n    }\n    return dNAString.trim().toUpperCase();\n};\n","import { sanitizeDNAString } from './sanitizeDNAString'\n\n\n/**\n* Complements a DNA string\n* @param {string} dNAString - DNA String\n* @returns {string} complement of DNA\n*/\nexport function complement(dNAString) {\n    let complementDNA = [],\n        dNAStringToUse = sanitizeDNAString(dNAString);\n\n    for(let d of dNAStringToUse ) {\n        switch(d) {\n            case 'A':\n                complementDNA.push('T');\n                break;\n            case 'T':\n                complementDNA.push('A');\n                break;\n            case 'G':\n                complementDNA.push('C');\n                break;\n            case 'C':\n                complementDNA.push('G');\n                break;\n            default:\n                if (!!console && !!console.log) {\n                    console.log(`Invalid nucleotide ${d} in string: ${dNAString}, managed to get past: isValid. Check for errors in unit test`);\n                }\n                throw `Invalid nucleotides: ${d} in string: ${dNAString}`;\n                break;\n        }\n    }\n\n    return complementDNA.join('');\n};\n","// internal use only\nfunction sanitizeDNAString(dNAString) {\n    if (false) {}\n    return dNAString.trim().toUpperCase();\n};\n\n/**\n* Complements a DNA string\n* @param {string} dNAString - DNA String\n* @returns {string} complement of DNA\n*/\nfunction complement(dNAString) {\n    let complementDNA = [],\n        dNAStringToUse = sanitizeDNAString(dNAString);\n\n    for(let d of dNAStringToUse ) {\n        switch(d) {\n            case 'A':\n                complementDNA.push('T');\n                break;\n            case 'T':\n                complementDNA.push('A');\n                break;\n            case 'G':\n                complementDNA.push('C');\n                break;\n            case 'C':\n                complementDNA.push('G');\n                break;\n            default:\n                if (!!console && !!console.log) {\n                    console.log(`Invalid nucleotide ${d} in string: ${dNAString}, managed to get past: isValid. Check for errors in unit test`);\n                }\n                throw `Invalid nucleotides: ${d} in string: ${dNAString}`;\n                break;\n        }\n    }\n\n    return complementDNA.join('');\n};\n\nexport { complement };\n// internal use only\nfunction sanitizeDNAString(dNAString) {\n    if (false) {}\n    return dNAString.trim().toUpperCase();\n};\n\nfunction  getCount(dNAString){\n     let dNAStringToUpper,\n     nucleotides = {\n         'A': 0,\n         'C': 0,\n         'T': 0,\n         'G': 0\n     };\n\n     dNAStringToUpper = sanitizeDNAString(dNAString);\n\n     for (let n of dNAStringToUpper) {\n         nucleotides[n] = nucleotides[n] + 1;\n     }\n     return [nucleotides.A, nucleotides.C, nucleotides.G, nucleotides.T ].join(' ');\n }\n\nexport { getCount };\n/**\n*   Ensures DNA string is valid\n*   @param {string} dNAString - DNA String\n*   @returns {boolean} True if DNA is valid, false otherwise\n*/\nfunction isValid(dNAString) {\n    let dNAStringToUse,\n            isDNAValid = true;\n\n            if (!dNAString || typeof dNAString !== 'string') {\n                return false;\n            }\n\n            dNAStringToUse = dNAString.trim().toUpperCase();\n\n            for (let n of dNAStringToUse) {\n                if (n === 'A' || n === 'C' || n === 'G' || n === 'T') {\n                    continue;\n                }\n\n                isDNAValid= false;\n                break;\n            };\n\n            return isDNAValid;\n}\n\nexport { isValid };\n// internal use only\nfunction sanitizeDNAString(dNAString) {\n    if (false) {}\n    return dNAString.trim().toUpperCase();\n};\n\n/**\n* Reverses a DNA string\n* @param {string} dnaString - DNA String\n* @param {boolean} ignoreCase [input=true] - Determines whether or not case is ignored\n* @returns {string} DNA string reversed\n*/\n function  reverse(dNAString){\n     let dNAStringToUse = sanitizeDNAString(dNAString);\n\n        return dNAStringToUse.split('').reverse().join('');\n }\n\nexport { reverse };\n// internal use only\nfunction sanitizeDNAString(dNAString) {\n    if (false) {}\n    return dNAString.trim().toUpperCase();\n};\n\nexport { sanitizeDNAString };\n// internal use only\nfunction invalidDNAMessage(dNAString) {\n    return `Invalid DNA string: ${dNAString}`;\n};\n\nexport { invalidDNAMessage };","import { sanitizeDNAString } from './sanitizeDNAString'\n\n export function  getCount(dNAString){\n     let dNAStringToUpper,\n     nucleotides = {\n         'A': 0,\n         'C': 0,\n         'T': 0,\n         'G': 0\n     };\n\n     dNAStringToUpper = sanitizeDNAString(dNAString);\n\n     for (let n of dNAStringToUpper) {\n         nucleotides[n] = nucleotides[n] + 1;\n     }\n     return [nucleotides.A, nucleotides.C, nucleotides.G, nucleotides.T ].join(' ');\n }\n","\n/**\n*   Ensures DNA string is valid\n*   @param {string} dNAString - DNA String\n*   @returns {boolean} True if DNA is valid, false otherwise\n*/\nexport function isValid(dNAString) {\n    let dNAStringToUse,\n            isDNAValid = true;\n\n            if (!dNAString || typeof dNAString !== 'string') {\n                return false;\n            }\n\n            dNAStringToUse = dNAString.trim().toUpperCase();\n\n            for (let n of dNAStringToUse) {\n                if (n === 'A' || n === 'C' || n === 'G' || n === 'T') {\n                    continue;\n                }\n\n                isDNAValid= false;\n                break;\n            };\n\n            return isDNAValid;\n}\n","import { sanitizeDNAString } from './sanitizeDNAString'\n\n/**\n* Reverses a DNA string\n* @param {string} dnaString - DNA String\n* @param {boolean} ignoreCase [input=true] - Determines whether or not case is ignored\n* @returns {string} DNA string reversed\n*/\n export function  reverse(dNAString){\n     let dNAStringToUse = sanitizeDNAString(dNAString);\n\n        return dNAStringToUse.split('').reverse().join('');\n }\n","\n// internal use only\nexport function invalidDNAMessage(dNAString) {\n    return `Invalid DNA string: ${dNAString}`;\n};\n"],"sourceRoot":"/source/"}